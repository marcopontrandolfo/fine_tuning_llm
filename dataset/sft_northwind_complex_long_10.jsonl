{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Esegui un'analisi comparativa avanzata dei fornitori sull'intervallo luglio-dicembre 2006 focalizzandoti sui primi 5 in termini di ricavo del Q4. Per ciascun fornitore includi: numero ordini Q3 (lug-set), numero ordini Q4 (ott-dic), ricavo totale Q3, ricavo totale Q4, variazione assoluta, variazione percentuale, fattore di crescita (Q4/Q3), quota del ricavo Q4 sul totale Q4 di tutti i fornitori e rank basato sul ricavo Q4. Considera solo i fornitori con almeno 3 ordini in ciascun trimestre e ricavo positivo in entrambi. Ordina per ricavo Q4 decrescente e limita a 5 risultati."},{"role":"assistant","content":"WITH per_supplier AS (\n  SELECT s.supplierId, s.companyName,\n         SUM(CASE WHEN o.orderDate BETWEEN '2006-07-01' AND '2006-09-30' THEN od.quantity*od.unitPrice*(1-COALESCE(od.discount,0)) END) AS rev_q3,\n         SUM(CASE WHEN o.orderDate BETWEEN '2006-10-01' AND '2006-12-31' THEN od.quantity*od.unitPrice*(1-COALESCE(od.discount,0)) END) AS rev_q4,\n         COUNT(DISTINCT CASE WHEN o.orderDate BETWEEN '2006-07-01' AND '2006-09-30' THEN o.orderId END) AS ord_q3,\n         COUNT(DISTINCT CASE WHEN o.orderDate BETWEEN '2006-10-01' AND '2006-12-31' THEN o.orderId END) AS ord_q4\n  FROM Supplier s\n  JOIN Product p ON p.supplierId = s.supplierId\n  JOIN OrderDetail od ON od.productId = p.productId\n  JOIN SalesOrder o ON o.orderId = od.orderId\n  GROUP BY s.supplierId, s.companyName\n), filtered AS (\n  SELECT *, (rev_q4 - rev_q3) AS delta_abs,\n         CASE WHEN rev_q3>0 THEN (rev_q4 - rev_q3)/rev_q3 END AS delta_pct,\n         CASE WHEN rev_q3>0 THEN rev_q4/rev_q3 END AS growth_factor\n  FROM per_supplier\n  WHERE ord_q3 >= 3 AND ord_q4 >= 3 AND rev_q3 > 0 AND rev_q4 > 0\n), totals AS (\n  SELECT SUM(rev_q4) AS tot_q4_rev FROM per_supplier\n)\nSELECT companyName, ord_q3, ord_q4, rev_q3, rev_q4,\n       delta_abs, delta_pct, growth_factor,\n       rev_q4 / totals.tot_q4_rev AS q4_share,\n       RANK() OVER (ORDER BY rev_q4 DESC) AS q4_rank\nFROM filtered\nCROSS JOIN totals\nORDER BY rev_q4 DESC\nLIMIT 5;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Per ogni categoria di prodotto costruisci una tabella di serie temporale mensile da luglio 2006 a febbraio 2007 che riporti il ricavo del mese, il ricavo cumulato progressivo della categoria, la quota del mese sul totale di tutte le categorie e la quota cumulata; ordina il risultato per mese e ricavo di categoria decrescente all'interno del mese."},{"role":"assistant","content":"WITH cat_month AS (\n  SELECT DATE_FORMAT(o.orderDate,'%Y-%m') AS ym, c.categoryId, c.categoryName,\n         SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS month_rev\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  JOIN Product p ON p.productId = od.productId\n  JOIN Category c ON c.categoryId = p.categoryId\n  WHERE o.orderDate BETWEEN '2006-07-01' AND '2007-02-28'\n  GROUP BY c.categoryId, c.categoryName, DATE_FORMAT(o.orderDate,'%Y-%m')\n), totals AS (\n  SELECT ym, SUM(month_rev) AS tot_rev\n  FROM cat_month GROUP BY ym\n), cat_running AS (\n  SELECT cm.*, SUM(cm.month_rev) OVER (PARTITION BY categoryId ORDER BY ym ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cat_cum_rev\n  FROM cat_month cm\n), month_running AS (\n  SELECT ym, SUM(tot_rev) OVER (ORDER BY ym ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_all_rev\n  FROM totals\n)\nSELECT cm.ym, cm.categoryName, cm.month_rev, cr.cat_cum_rev,\n       cm.month_rev / t.tot_rev AS month_share,\n       cr.cat_cum_rev / mr.cum_all_rev AS cum_share\nFROM cat_month cm\nJOIN cat_running cr ON cr.categoryId = cm.categoryId AND cr.ym = cm.ym\nJOIN totals t ON t.ym = cm.ym\nJOIN month_running mr ON mr.ym = cm.ym\nORDER BY cm.ym, cm.month_rev DESC;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Elabora un'analisi più articolata: identifica i 10 prodotti con la maggiore variazione percentuale di ricavo confrontando l'intero mese di agosto 2006 con l'intero mese di gennaio 2007; per ciascun prodotto riporta il ricavo di agosto, il ricavo di gennaio, la variazione assoluta e la variazione percentuale. Includi solo prodotti con ricavo positivo in almeno uno dei due mesi; considera la variazione percentuale definita solo se agosto ha ricavo > 0; in caso contrario lascia la percentuale non valorizzata e posiziona tali casi in fondo. In presenza di ex aequo sulla variazione percentuale, ordina per variazione assoluta decrescente; l'ordinamento principale resta per variazione percentuale decrescente."},{"role":"assistant","content":"WITH prod_two AS (\n  SELECT p.productId, p.productName,\n         SUM(CASE WHEN DATE_FORMAT(o.orderDate,'%Y-%m')='2006-08' THEN od.quantity*od.unitPrice*(1-COALESCE(od.discount,0)) END) AS rev_aug,\n         SUM(CASE WHEN DATE_FORMAT(o.orderDate,'%Y-%m')='2007-01' THEN od.quantity*od.unitPrice*(1-COALESCE(od.discount,0)) END) AS rev_jan\n  FROM Product p\n  JOIN OrderDetail od ON od.productId = p.productId\n  JOIN SalesOrder o ON o.orderId = od.orderId\n  GROUP BY p.productId, p.productName\n), filtered AS (\n  SELECT *, (rev_jan - rev_aug) AS delta_abs,\n         CASE WHEN rev_aug>0 THEN (rev_jan - rev_aug)/rev_aug END AS delta_pct\n  FROM prod_two\n  WHERE COALESCE(rev_aug,0) > 0 OR COALESCE(rev_jan,0) > 0\n)\nSELECT productName, rev_aug, rev_jan, delta_abs, delta_pct\nFROM filtered\nORDER BY (delta_pct IS NULL), delta_pct DESC, delta_abs DESC\nLIMIT 10;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Costruisci una classifica estesa dei paesi di spedizione per l'intero anno 2006 (1 gen - 31 dic) includendo: ricavo totale (somma di quantity*unitPrice*(1-COALESCE(discount,0))), ricavo medio per ordine, numero ordini, ricavo medio per riga (ricavo totale / righe totali), rank basato sul ricavo totale, quota del ricavo totale sul totale globale, segmentazione (TOP_QUARTILE / UPPER_HALF / LOWER_HALF) derivata dalla posizione ordinata per ricavo, e il rapporto tra il ricavo medio per riga del paese e il ricavo medio per riga globale. Includi solo paesi con almeno 10 ordini, usa solo la data dell'ordine e ordina per ricavo totale decrescente."},{"role":"assistant","content":"WITH per_order AS (\n  SELECT o.orderId, o.shipCountry, SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS ord_rev, COUNT(*) AS line_cnt\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  WHERE YEAR(o.orderDate)=2006\n  GROUP BY o.orderId, o.shipCountry\n), agg AS (\n  SELECT shipCountry, SUM(ord_rev) AS total_rev, AVG(ord_rev) AS avg_ord_rev, COUNT(*) AS orders, SUM(line_cnt) AS total_lines\n  FROM per_order\n  GROUP BY shipCountry\n  HAVING COUNT(*) >= 10\n)\nSELECT shipCountry,\n       total_rev,\n       avg_ord_rev,\n       orders,\n       total_rev/total_lines AS avg_line_rev,\n       RANK() OVER (ORDER BY total_rev DESC) AS revenue_rank,\n       total_rev / SUM(total_rev) OVER () AS rev_share,\n       CASE\n         WHEN ROW_NUMBER() OVER (ORDER BY total_rev DESC) <= CEIL(COUNT(*) OVER () * 0.25) THEN 'TOP_QUARTILE'\n         WHEN ROW_NUMBER() OVER (ORDER BY total_rev DESC) <= CEIL(COUNT(*) OVER () * 0.50) THEN 'UPPER_HALF'\n         ELSE 'LOWER_HALF'\n       END AS segment,\n       (total_rev/total_lines) / (SUM(total_rev) OVER () / SUM(total_lines) OVER ()) AS rel_avg_line_rev\nFROM agg\nORDER BY total_rev DESC;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Estendi l'analisi cronologica degli ordini per dipendente (settembre 2006 - gennaio 2007) includendo anche il contesto territoriale: per ogni ordine riporta numero progressivo, ricavo, media mobile 3 ordini, variazione % vs precedente, cumulato dipendente, rank per ricavo nello storico, quota del giorno, rapporto vs media cumulata (ricavo/(cumulato/progressivo)), bucket dimensionale (SMALL <100, MEDIUM <500, LARGE altrimenti) e, a livello anagrafico, l'elenco dei territori e delle aree (regioni) associati al dipendente. Usa LEFT JOIN per non perdere i dipendenti senza territorio; ordina per cognome, nome e data."},{"role":"assistant","content":"WITH ord_base AS (\n  SELECT o.orderId, o.employeeId, o.orderDate, SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS revenue\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  WHERE o.orderDate BETWEEN '2006-09-01' AND '2007-01-31'\n  GROUP BY o.orderId, o.employeeId, o.orderDate\n), seq AS (\n  SELECT ord_base.*,\n         ROW_NUMBER() OVER (PARTITION BY employeeId ORDER BY orderDate) AS rn,\n         AVG(revenue) OVER (PARTITION BY employeeId ORDER BY orderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS ma3,\n         LAG(revenue) OVER (PARTITION BY employeeId ORDER BY orderDate) AS prev_rev,\n         SUM(revenue) OVER (PARTITION BY employeeId ORDER BY orderDate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS emp_cum_rev,\n         RANK() OVER (PARTITION BY employeeId ORDER BY revenue DESC) AS rev_rank_emp\n  FROM ord_base\n), day_tot AS (\n  SELECT orderDate, SUM(revenue) AS day_rev\n  FROM ord_base\n  GROUP BY orderDate\n), emp_geo AS (\n  SELECT et.employeeId,\n         GROUP_CONCAT(DISTINCT t.territoryDescription ORDER BY t.territoryDescription SEPARATOR ', ') AS territories,\n         GROUP_CONCAT(DISTINCT r.regionDescription ORDER BY r.regionDescription SEPARATOR ', ') AS regions\n  FROM EmployeeTerritory et\n  JOIN Territory t ON t.territoryId = et.territoryId\n  JOIN Region r ON r.regionId = t.regionId\n  GROUP BY et.employeeId\n), enriched AS (\n  SELECT s.*, DATE_FORMAT(s.orderDate,'%Y-%m') AS ym, dt.day_rev,\n         s.revenue / dt.day_rev AS day_share,\n         CASE WHEN s.rn > 0 THEN s.revenue / (s.emp_cum_rev / s.rn) END AS vs_avg_so_far,\n         CASE\n           WHEN s.revenue < 100 THEN 'SMALL'\n           WHEN s.revenue < 500 THEN 'MEDIUM'\n           ELSE 'LARGE'\n         END AS size_bucket,\n         CASE WHEN prev_rev>0 THEN (s.revenue - prev_rev)/prev_rev END AS pct_change_prev\n  FROM seq s\n  JOIN day_tot dt ON dt.orderDate = s.orderDate\n)\nSELECT e.firstname, e.lastname, enriched.orderId, enriched.orderDate,\n       enriched.revenue, rn, rev_rank_emp, ma3, emp_cum_rev, day_rev, day_share,\n       vs_avg_so_far, size_bucket, pct_change_prev,\n       COALESCE(eg.territories,'NO_TERRITORY') AS territories,\n       COALESCE(eg.regions,'NO_REGION') AS regions\nFROM enriched\nJOIN Employee e ON e.employeeId = enriched.employeeId\nLEFT JOIN emp_geo eg ON eg.employeeId = enriched.employeeId\nORDER BY e.lastname, e.firstname, enriched.orderDate;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Trova tutti i casi nel 2006 in cui un singolo prodotto rappresenta almeno il 12% del ricavo totale del mese; per ciascun mese e prodotto riporta: categoria, ricavo del prodotto, totale del mese, quota, rank nel mese basato sulla quota, numero di ordini e numero di righe che contribuiscono, ricavo medio per riga e la variazione della quota rispetto al mese precedente dello stesso prodotto (se disponibile). Ordina per mese e quota decrescente."},{"role":"assistant","content":"WITH prod_month AS (\n  SELECT DATE_FORMAT(o.orderDate,'%Y-%m') AS ym, p.productId, p.productName, c.categoryId, c.categoryName,\n         SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS prod_rev,\n         COUNT(DISTINCT o.orderId) AS orders_cnt,\n         COUNT(*) AS line_cnt\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  JOIN Product p ON p.productId = od.productId\n  JOIN Category c ON c.categoryId = p.categoryId\n  WHERE YEAR(o.orderDate)=2006\n  GROUP BY DATE_FORMAT(o.orderDate,'%Y-%m'), p.productId, p.productName, c.categoryId, c.categoryName\n), month_tot AS (\n  SELECT ym, SUM(prod_rev) AS month_rev\n  FROM prod_month\n  GROUP BY ym\n), ranked AS (\n  SELECT pm.*, mt.month_rev,\n         pm.prod_rev / mt.month_rev AS share,\n         RANK() OVER (PARTITION BY pm.ym ORDER BY pm.prod_rev/mt.month_rev DESC) AS rank_by_share\n  FROM prod_month pm\n  JOIN month_tot mt ON mt.ym = pm.ym\n), per_prod_seq AS (\n  SELECT ranked.*,\n         LAG(share) OVER (PARTITION BY productId ORDER BY ym) AS prev_share\n  FROM ranked\n)\nSELECT ym, productName, categoryName,\n       prod_rev, month_rev, share, rank_by_share,\n       orders_cnt, line_cnt, prod_rev/line_cnt AS avg_line_rev,\n       CASE WHEN prev_share IS NOT NULL THEN share - prev_share END AS delta_share_vs_prev_month\nFROM per_prod_seq\nWHERE share >= 0.12\nORDER BY ym, share DESC;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Seleziona gli acquirenti (clienti) con almeno 6 ordini tra luglio 2006 e febbraio 2007 e per ciascuno produci una tabella mensile con: ricavo del mese, ricavo cumulato cliente, rank nel mese per ricavo, quota del ricavo cumulato sul totale cumulato di tutti i clienti eleggibili, e l'elenco dei segmenti demografici associati (se presenti). Evidenzia anche un flag che indichi se il cliente ha segmentazione (EXISTS)."},{"role":"assistant","content":"WITH ord AS (\n  SELECT o.orderId, o.custId, DATE_FORMAT(o.orderDate,'%Y-%m') AS ym, SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS rev\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  WHERE o.orderDate BETWEEN '2006-07-01' AND '2007-02-28'\n  GROUP BY o.orderId, o.custId, DATE_FORMAT(o.orderDate,'%Y-%m')\n), counts AS (\n  SELECT custId, COUNT(orderId) AS ord_cnt FROM ord GROUP BY custId\n), eligible AS (\n  SELECT custId FROM counts WHERE ord_cnt >= 6\n), cust_month AS (\n  SELECT o.custId, o.ym, SUM(rev) AS month_rev\n  FROM ord o JOIN eligible e ON e.custId = o.custId\n  GROUP BY o.custId, o.ym\n), cust_enriched AS (\n  SELECT cust_month.*, SUM(month_rev) OVER (PARTITION BY custId ORDER BY ym ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cust_cum_rev\n  FROM cust_month\n), month_tot AS (\n  SELECT ym, SUM(month_rev) AS tot_month_rev FROM cust_month GROUP BY ym\n), cum_tot AS (\n  SELECT ym, SUM(tot_month_rev) OVER (ORDER BY ym ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_all_rev FROM month_tot\n), ranked_month AS (\n  SELECT ce.*, RANK() OVER (PARTITION BY ym ORDER BY month_rev DESC) AS rk\n  FROM cust_enriched ce\n), cust_demo AS (\n  SELECT ccd.custId, GROUP_CONCAT(DISTINCT cd.customerDesc ORDER BY cd.customerDesc SEPARATOR ', ') AS segments\n  FROM CustCustomerDemographics ccd\n  JOIN CustomerDemographics cd ON cd.customerTypeId = ccd.customerTypeId\n  GROUP BY ccd.custId\n)\nSELECT c.companyName, rm.ym, rm.month_rev, rm.cust_cum_rev, rk AS month_rank,\n       rm.cust_cum_rev / ct.cum_all_rev AS cust_cum_share,\n       COALESCE(d.segments,'NO_SEGMENT') AS segments,\n       EXISTS(SELECT 1 FROM CustCustomerDemographics x WHERE x.custId = rm.custId) AS has_demographics\nFROM ranked_month rm\nJOIN Customer c ON c.custId = rm.custId\nJOIN cum_tot ct ON ct.ym = rm.ym\nLEFT JOIN cust_demo d ON d.custId = rm.custId\nORDER BY c.companyName, rm.ym;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Valuta la puntualità per spedizioniere nel 2006: seleziona gli operatori di spedizione con tempo medio di consegna (shippedDate - orderDate) superiore a 6 giorni e ricavo totale maggiore della mediana dei ricavi dei corrieri; riporta anche la differenza tra il loro ricavo e tale mediana. Usa una formulazione variata e includi sia puntualità sia volumi (ricavi)."},{"role":"assistant","content":"WITH ord_ship AS (\n  SELECT o.orderId, o.shipVia, DATEDIFF(o.shippedDate,o.orderDate) AS ship_days, SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS ord_rev\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  WHERE YEAR(o.orderDate)=2006\n  GROUP BY o.orderId, o.shipVia, o.orderDate, o.shippedDate\n), ship_metrics AS (\n  SELECT s.shipperId, s.companyName, AVG(os.ship_days) AS avg_ship_days, SUM(os.ord_rev) AS total_rev\n  FROM ord_ship os\n  JOIN Shipper s ON s.shipperId = os.shipVia\n  GROUP BY s.shipperId, s.companyName\n), ordered AS (\n  SELECT total_rev, ROW_NUMBER() OVER (ORDER BY total_rev) AS rn, COUNT(*) OVER () AS cnt\n  FROM ship_metrics\n), median_calc AS (\n  SELECT AVG(total_rev) AS median_rev\n  FROM ordered\n  WHERE rn IN (FLOOR((cnt+1)/2), CEIL((cnt+1)/2))\n)\nSELECT companyName, total_rev, avg_ship_days, (total_rev - mc.median_rev) AS delta_vs_median\nFROM ship_metrics sm\nCROSS JOIN median_calc mc\nWHERE sm.avg_ship_days > 6 AND sm.total_rev > mc.median_rev\nORDER BY sm.total_rev DESC;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Produci una vista di stagionalità estesa da luglio 2006 a febbraio 2007 con: mese, numero ordini, ricavo totale, ricavo medio per ordine, ricavo mediano per ordine, variazione percentuale del ricavo totale sul mese precedente e deviazione standard dei ricavi per ordine."},{"role":"assistant","content":"WITH per_order AS (\n  SELECT o.orderId, DATE_FORMAT(o.orderDate,'%Y-%m') AS ym, SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS ord_rev\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  WHERE o.orderDate BETWEEN '2006-07-01' AND '2007-02-28'\n  GROUP BY o.orderId, DATE_FORMAT(o.orderDate,'%Y-%m')\n), month_stats AS (\n  SELECT ym, COUNT(*) AS orders, SUM(ord_rev) AS revenue, AVG(ord_rev) AS avg_rev, STDDEV_POP(ord_rev) AS std_rev\n  FROM per_order GROUP BY ym\n), ordered AS (\n  SELECT ym, ord_rev, ROW_NUMBER() OVER (PARTITION BY ym ORDER BY ord_rev) AS rn, COUNT(*) OVER (PARTITION BY ym) AS cnt\n  FROM per_order\n), med AS (\n  SELECT ym, AVG(ord_rev) AS median_rev\n  FROM ordered\n  WHERE rn IN (FLOOR((cnt+1)/2), CEIL((cnt+1)/2))\n  GROUP BY ym\n)\nSELECT ms.ym, orders, revenue, avg_rev, med.median_rev, std_rev,\n       LAG(revenue) OVER (ORDER BY ms.ym) AS prev_revenue,\n       CASE WHEN LAG(revenue) OVER (ORDER BY ms.ym) > 0 THEN (revenue - LAG(revenue) OVER (ORDER BY ms.ym))/LAG(revenue) OVER (ORDER BY ms.ym) END AS pct_change\nFROM month_stats ms\nJOIN med ON med.ym = ms.ym\nORDER BY ms.ym;"}]}
{"messages":[{"role":"system","content":"You are an expert SQL assistant for the Northwind MySQL database.\nRules: output ONLY the final SQL query; use MySQL dialect; SELECT only;\nuse existing tables/columns; prefer explicit JOIN ON with correct FKs;\ncompute revenue as quantity*unitPrice*(1-COALESCE(discount,0)) when asked."},{"role":"user","content":"Per ogni categoria nel 2006 estrai i primi 3 prodotti per ricavo, mostrando anche la percentuale del ricavo del prodotto sul totale della categoria e il rank; ordina globalmente per categoria e rank."},{"role":"assistant","content":"WITH cat_prod AS (\n  SELECT c.categoryId, c.categoryName, p.productId, p.productName, SUM(od.quantity*od.unitPrice*(1-COALESCE(od.discount,0))) AS prod_rev\n  FROM SalesOrder o\n  JOIN OrderDetail od ON od.orderId = o.orderId\n  JOIN Product p ON p.productId = od.productId\n  JOIN Category c ON c.categoryId = p.categoryId\n  WHERE YEAR(o.orderDate)=2006\n  GROUP BY c.categoryId, c.categoryName, p.productId, p.productName\n), cat_tot AS (\n  SELECT categoryId, SUM(prod_rev) AS cat_rev FROM cat_prod GROUP BY categoryId\n), ranked AS (\n  SELECT cp.*, cp.prod_rev/ct.cat_rev AS share_cat, ROW_NUMBER() OVER (PARTITION BY cp.categoryId ORDER BY cp.prod_rev DESC) AS rk\n  FROM cat_prod cp JOIN cat_tot ct ON ct.categoryId = cp.categoryId\n)\nSELECT categoryName, productName, prod_rev, share_cat, rk\nFROM ranked\nWHERE rk <= 3\nORDER BY categoryName, rk;"}]}
